# Peter Caya
# Purpose: The purpose of this script is to provide the structures necessary for working with graphs. 
# Comparison method taken from StackOverflow below:
#https://stackoverflow.com/questions/9623114/check-if-two-unordered-lists-are-equal#:~:text=Python%20has%20a%20built%2Din,the%20comparison%20will%20be%20unordered.&text=If%20you%20don't%20want,always%20be%20faster%20then%20collections.
import collections
from typing import Counter
# compare
# Inputs:
# • x/y - a list of elements to be reviewed
# Outputs:
# • TRUE/FALSE for whether the same elements and the same number of elements are included in both lists.
compare = lambda x, y: collections.Counter(x) == collections.Counter(y) 

# Get a list of labels for each node in the graph:
def get_neighbor_labels(graph_object):
    def get_node_neighbor_labels(graph_object,node_key):
        current_node = graph_object[node_key]
        current_neighbors = current_node["Neighbor"]    
        neighbor_labels = [graph_object[current_neighbors[x]]["Label"] for x in range(len(current_neighbors))     ]
        # We sort the details of each list to ensure that the orderings performed later work properly.
        neighbor_labels.sort()
        return(neighbor_labels)
    graph_with_label_values = {x:get_node_neighbor_labels(graph_object=graph_object, node_key = x) for x in graph_object.keys()        }
    return(graph_with_label_values)

def gen_new_labels(graph_results):
    # Convert each object generated by the counter function into a character object. This is for the purpose of matching later on.
    all_labels = [str(collections.Counter(graph_results[x])) for x in graph_results.keys()] 
    # Get the unique values from all_labels:
    unique_labels = [str(x) for x in collections.Counter(all_labels).keys()]
    # Get the range of labels from the unique_labels object. This is to be used to generate new indices for the results.
    new_labels = range(len(unique_labels))
    # Placeholder dictionary: This carries the new labels for each node in the graph that we've described above:
    new_labels_for_replacement = {x:"NA" for x in graph_results.keys()}
    # The function below uses the actual group type to generate new labels for each node. This number will be the same as the number of unique values.
    for i in range(len(unique_labels)):
        unique_ind = i
        unique_match_bools = [ unique_labels[i] == x for x in all_labels  ]
        new_label_keys = list(new_labels_for_replacement.keys())
        for orig_labels in range( len(new_labels_for_replacement)):
            if unique_match_bools[orig_labels]:
                new_labels_for_replacement[new_label_keys[orig_labels]]=i    
    return(new_labels_for_replacement)

# This function relabels a graph:
def relabel_graph(graph_for_relabeling):
    # Get the associated labels for each node of the graph:
    graph_labelings = get_neighbor_labels(graph_for_relabeling)
    # Generate new labelings for each node:
    new_labels = gen_new_labels(graph_labelings)
    # Relabel the original graph using the new_labels object:
    for cur_label in graph_for_relabeling.keys():
        graph_for_relabeling[cur_label]["Label"] = new_labels[cur_label]
    return(graph_for_relabeling)

# Quickly extract the labels of each graph node:
def get_labels(graph_object):
    ret_dictionary = {x:graph_object[x]["Label"] for x in graph_object.keys()}
    return(ret_dictionary)

# The purpose of the function below is to test whether the labels in the grpah have changed or not from the previous graph:
# previous_graph_iteration is the label from the previous graph that's being used.
# current_graph_iteration is the lables from the current graph
def change_label_test(current_graph_iteration, previous_graph_iteration):
    test_match = [previous_graph_iteration[x]==current_graph_iteration[x] for x in previous_graph_iteration.keys()]
    # Test to see if all labels are the same from the previous iteration:
    test_result = all(x for x in test_match)
    return(test_result)
 
# The final function used to generate the canonical form of the graph input. For the structure of the graph input that needs to be used, see the dictionary object defined below as graph_example_1:
def create_graph_canonical_form(graph_for_relabeling):
    i = 0
    print("Running iteration " + str(i) + ".")
    label_test_results = False
    while not(label_test_results):
        previous_graph_label = get_labels(graph_for_relabeling)
        current_graph = relabel_graph(graph_for_relabeling)
        current_graph_labels = get_labels(current_graph)
        label_test_results = change_label_test(current_graph_iteration=current_graph_labels,previous_graph_iteration=previous_graph_label)
        i+=1
        print("Running iteration " + str(i) + ".")
    return(current_graph)

# We define a simple example taken from the Weisfeiller-Lehman algorithm blog post. We can see that this generates the same form/labelings that were generated in that blog post:
graph_example_1 = {1:{"Label":1,"Neighbor":[2,3,5]},
              2:{"Label":1,"Neighbor":[1,3]},
              3:{"Label":1,"Neighbor":[1,2,4]},
              4:{"Label":1,"Neighbor":[3,5]},
              5:{"Label":1,"Neighbor":[1,4]}}

# When we run the create_graph_canonical form function on the example above, we see that we get the same labels as would be generated if we proceeded manually.
create_graph_canonical_form(graph_example_1)
